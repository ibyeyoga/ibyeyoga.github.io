<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[ip2long出现负数的解决方案]]></title>
      <url>/2017/05/02/ip2long%E5%87%BA%E7%8E%B0%E8%B4%9F%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　在PHP开发中，有时候会遇到一些需求，例如：获取用户的IP地址，并存到数据库当中。一般做法是将IP地址转变为整型存入数据库当中，至于如何将IP地址转成整型，有很多做法<a href="ip2long、INET_ATON">^1</a>，而我习惯用<code>ip2long</code>这个函数来处理，当然你也可以自己写一个更好的函数。</p>
<p>　　当然<code>ip2long</code>转化的IP地址并不是很完美，某些地址存在BUG，就是转换后的地址会变成一个负数(原因是溢出了)。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>　　最简单的方法是使用<code>decbin</code>将<code>ip2long</code>的返回值转成二进制，然后再通过<code>bindec</code>将结果转回十进制。(官方也推荐过另一个解决办法，在官方手册中有说明)</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?PHP</span></div><div class="line"><span class="keyword">echo</span> bindec(decbin(ip2long($ip)));<span class="comment">//也可以 printf('%u', ip2long($ip));</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 疑难杂症 </tag>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo添加站内搜索功能]]></title>
      <url>/2017/04/22/Hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>　　今天的主角是<code>hexo-generator-search</code>，这个插件可以帮助我们实现Hexo的站内搜索功能，而且<code>hexo-generator-search</code>安装很简单，只需要一行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-search --save</div></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>　　安装完<code>hexo-generator-search</code>之后就可以进行配置了，我们可以打开博客目录的<code>_config.yml</code>文件进行配置，</p>
<p>　　在<code>_config.yml</code>文件中添加下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">search:</div><div class="line">  path: search.xml</div><div class="line">  field: post</div></pre></td></tr></table></figure>
<p>　　注意：安装了Next主题，需要添加代码的是Next主题里面的<code>_config.yml</code> ，即：<code>博客根目录/themes/next/_config.yml</code>还需要将配置项<code>local_search</code>的<code>enable</code>值设置为<code>true</code>。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>　　该插件会在你执行<code>hexo g</code>的时候，生成搜索索引。当你上传到服务器之后就可以使用了。</p>
<p><img src="http://oivwa6p90.bkt.clouddn.com/1492865826.png" width="938" height="430"></p>
]]></content>
      
        <categories>
            
            <category> 技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 站内搜索 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown如何做到首行缩进]]></title>
      <url>/2017/04/22/Markdown%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%A6%96%E8%A1%8C%E7%BC%A9%E8%BF%9B/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　最近开始用Markdown写文章，发现Markdown默认并不支持首行缩进，很多时候，我的习惯都是在每一个自然段的开头空两格。如下图所示：</p>
<p><img src="http://oivwa6p90.bkt.clouddn.com/1492863613.png" width="539" height="173"></p>
<p>　　我试过使用<code>tab</code>按键，发现文章发布之后，并没有达到预期效果。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li><p>修改显示markdown文章的页面的CSS样式</p>
<p>如：text-indent: 2em;</p>
</li>
<li><p>使用一定数量的<code>&amp;nbsp;</code>来达到顶格的效果</p>
</li>
<li><p>将输入法的符号设置成全角，然后再行首打两个空格</p>
</li>
</ol>
<p><img src="http://oivwa6p90.bkt.clouddn.com/1492864487.png" width="230" height="165"></p>
]]></content>
      
        <categories>
            
            <category> 技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 疑难杂症 </tag>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS7之后的同步请求解决方案]]></title>
      <url>/2017/04/22/iOS7%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​ 　　iOS7以前，iOS的网络请求一般是通过<code>NSURLConnection sendSynchronousRequest</code>来处理，但是iOS7之后，<code>NSURLConnection</code>已经被苹果废除了，取而代之的是<code>NSURLSession</code>，而<code>NSURLSession</code>并没有提供像<code>sendSynchronousRequest</code>这种同步请求方法，那么如果实际项目中需要用到同步请求，要怎样解决呢？</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>　　下面是我的一个解决方案，就是使用GDC信号量。</p>
<h2 id="主角semaphore"><a href="#主角semaphore" class="headerlink" title="主角semaphore"></a>主角semaphore</h2><p>　　dispatch_semaphore_create　　　创建一个semaphore对象<br>　　dispatch_semaphore_signal　　　 发送一个信号<br>　　dispatch_semaphore_wait　　　　等待信号</p>
<p>　　dispatch_semaphore_create需要传入一个整型值作为参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>1️⃣我们创建一个semaphore对象，总信号量设置为0，如：dispatch_semaphore_create(0)；<br>2️⃣在异步执行的方法结尾为第一步创建的semaphore对象发一个信号，使它的总信号量加一，如：dispatch_semaphore_signal(semaphore)；<br>3️⃣在需要阻塞的地方加上dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)，DISPATCH_TIME_FOREVER的意思是如果semaphore的信号量一直是0的话，就一直等下去。</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//step 1:创建同步信号量</div><div class="line">dispatch_semaphore_t semaphore=dispatch_semaphore_create(0);</div><div class="line">//step 2:创建请求</div><div class="line">NSMutableURLRequest *request=[NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]];</div><div class="line">    [request setHTTPMethod:@&quot;get&quot;];</div><div class="line">    [request setValue:@&quot;iOS&quot; forHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">//step 3:创建urlsession实例</div><div class="line">NSURLSession *session=[NSURLSession sharedSession];</div><div class="line">//step 4:使用dataTaskWithRequest方法连接服务器</div><div class="line">    NSURLSessionDataTask *task=[session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">        	//这里处理错误</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">         	//这里处理服务器返回的数据</div><div class="line">        &#125;</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;];</div><div class="line">[task resume];</div><div class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 苹果 </tag>
            
            <tag> iPhone </tag>
            
            <tag> 同步请求 </tag>
            
            <tag> iOS7之后的同步请求解决方案 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac中使用brew安装php7失败的解决方案]]></title>
      <url>/2017/03/27/Mac%E4%B8%AD%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85php7%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="Mac中使用brew安装php7失败的解决方案"><a href="#Mac中使用brew安装php7失败的解决方案" class="headerlink" title="Mac中使用brew安装php7失败的解决方案"></a>Mac中使用brew安装php7失败的解决方案</h1><p>​    之前写PHP一直使用mac自带的PHP5.6，看到PHP7的一些特性之后决定尝一下鲜，百度了安装教程之后，发现我使用brew按照教程安装php7还是会出现问题。</p>
<p>​    虽然是几个月前的笔记，我总结了之后，放到博客上，供自己或网友做一个参考。</p>
<h2 id="情况1：没有libphp7-so"><a href="#情况1：没有libphp7-so" class="headerlink" title="情况1：没有libphp7.so"></a>情况1：没有libphp7.so</h2><p>​    安装过程中，可能会提示缺少libphp7.so</p>
<p>​    解决方法：</p>
<p>​    xcode-select –install，之后再执行brew install php70即可，如果还不行，将xcode升级到8.1</p>
<h2 id="情况2：安装完之后apache不解释php文件"><a href="#情况2：安装完之后apache不解释php文件" class="headerlink" title="情况2：安装完之后apache不解释php文件"></a>情况2：安装完之后apache不解释php文件</h2><p>​    其实这两种情况经常同时出现，因为xcode版本的问题导致libphp7.so在安装的过程中没有安装好，这样的话配置apache的时候就会解释不了php文件了。</p>
<p>​    解决方法：打开httpd.conf(mac自带apache路径/etc/apache2/httpd.conf)，<br>添加LoadModule php7_module /usr/local/Cellar/php70/7.0.14_7/libexec/apache2/libphp7.so，<br>之后在AddType application/x-gzip .gz .tgz的下一行加上AddType application/x-httpd-php .php</p>
]]></content>
      
        <categories>
            
            <category> 技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 疑难杂症 </tag>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
